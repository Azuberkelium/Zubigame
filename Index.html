<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DartMerge</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React, ReactDOM, and Babel CDNs for rendering the JSX -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
</head>
<body class="bg-gray-900 text-white font-sans">

    <!-- This is the root element where the React application will be rendered -->
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;
        const rootElement = ReactDOM.createRoot(document.getElementById('root'));

        const SPECIAL_BLOCKS_COST = {
            swap: 50000,
            hammer: 100000,
            doubler: 150000,
            freeze: 200000,
            bomb: 250000,
        };

        const App = () => {
            // Generates the initial numbers (2, 4, 8, ...) up to 32768
            const numbers = (() => {
                const nums = [];
                const colors = [
                    'bg-red-500', 'bg-blue-500', 'bg-green-500', 'bg-yellow-500', 'bg-purple-500',
                    'bg-pink-500', 'bg-indigo-500', 'bg-teal-500', 'bg-orange-500', 'bg-cyan-500',
                    'bg-fuchsia-500', 'bg-lime-500', 'bg-rose-500', 'bg-amber-500', 'bg-emerald-500'
                ];
                for (let i = 2, j = 0; i <= 32768; i *= 2, j++) {
                    nums.push({ value: i, color: colors[j % colors.length] });
                }
                return nums;
            })();

            const [dropZone, setDropZone] = useState([]);
            const [grid, setGrid] = useState(Array(5).fill(null).map(() => Array(5).fill(null)));
            const [score, setScore] = useState(0);
            const [gameOver, setGameOver] = useState(false);
            const [highestValue, setHighestValue] = useState(null);
            const [selectedDropZoneValue, setSelectedDropZoneValue] = useState(null);
            const [specialBlocks, setSpecialBlocks] = useState({
                swap: 0,
                hammer: 0,
                doubler: 0,
                freeze: 0,
                bomb: 0,
            });
            const [activeSpecialBlock, setActiveSpecialBlock] = useState(null);
            const [swapSelection, setSwapSelection] = useState([]);
            const [message, setMessage] = useState('');

            // Recalculate the score whenever the grid changes
            useEffect(() => {
                let newScore = 0;
                let newHighest = 0;
                let gridFull = true;
                for (const row of grid) {
                    for (const cell of row) {
                        if (cell) {
                            newScore += cell.value;
                            if (cell.value > newHighest) {
                                newHighest = cell.value;
                            }
                        } else {
                            gridFull = false;
                        }
                    }
                }
                setScore(newScore);
                setHighestValue(newHighest);
                setGameOver(gridFull);
            }, [grid]);

            // Handle clicking a number from the top section
            const handleNumberClick = (value) => {
                if (dropZone.length < 3) {
                    const numberToAdd = numbers.find(n => n.value === value);
                    if (numberToAdd) {
                        setDropZone([...dropZone, { ...numberToAdd }]);
                    }
                }
            };

            // Handle clicking the undo button
            const handleUndo = () => {
                if (dropZone.length > 0) {
                    const newDropZone = dropZone.slice(0, -1);
                    setDropZone(newDropZone);
                    if (selectedDropZoneValue === dropZone[dropZone.length - 1]?.value) {
                        setSelectedDropZoneValue(null);
                    }
                }
            };

            // Handle clicking a number in the drop zone
            const handleDropZoneClick = (value) => {
                setSelectedDropZoneValue(value);
                setActiveSpecialBlock(null);
                setMessage('');
            };

            // Recursive function to merge adjacent blocks
            const mergeBlocks = (currentGrid) => {
                let merged = false;
                let newGrid = JSON.parse(JSON.stringify(currentGrid));

                const checkAndMerge = (r, c) => {
                    if (newGrid[r][c] && !newGrid[r][c].isFrozen) {
                        const value = newGrid[r][c].value;
                        const neighbors = [
                            [r - 1, c], [r + 1, c], [r, c - 1], [r, c + 1]
                        ];

                        for (const [nr, nc] of neighbors) {
                            if (nr >= 0 && nr < 5 && nc >= 0 && nc < 5 && newGrid[nr][nc] && newGrid[nr][nc].value === value && !newGrid[nr][nc].isFrozen) {
                                newGrid[r][c] = { value: value * 2, color: newGrid[r][c].color };
                                newGrid[nr][nc] = null;
                                merged = true;
                                newGrid = gravity(newGrid);
                                newGrid = mergeBlocks(newGrid);
                                return;
                            }
                        }
                    }
                };

                for (let r = 0; r < 5; r++) {
                    for (let c = 0; c < 5; c++) {
                        if (newGrid[r][c]) {
                            checkAndMerge(r, c);
                            if(merged) break;
                        }
                    }
                    if(merged) break;
                }
                return newGrid;
            };

            // Apply gravity: numbers fall to the lowest available spot
            const gravity = (currentGrid) => {
                const newGrid = currentGrid.map(row => [...row]);
                for (let c = 0; c < 5; c++) {
                    let writeRow = 4;
                    for (let r = 4; r >= 0; r--) {
                        if (newGrid[r][c]) {
                            if (r !== writeRow) {
                                newGrid[writeRow][c] = newGrid[r][c];
                                newGrid[r][c] = null;
                            }
                            writeRow--;
                        }
                    }
                }
                return newGrid;
            };

            // Handle clicking a column in the grid to drop a number
            const handleGridDrop = (col) => {
                if (!selectedDropZoneValue) return;

                let newGrid = [...grid];
                let row = -1;
                for (let r = 4; r >= 0; r--) {
                    if (!newGrid[r][col]) {
                        row = r;
                        break;
                    }
                }

                if (row !== -1) {
                    const selectedIndex = dropZone.findIndex(n => n.value === selectedDropZoneValue);
                    if (selectedIndex === -1) return;

                    const selectedNumber = dropZone[selectedIndex];
                    newGrid[row][col] = selectedNumber;

                    const newDropZone = dropZone.filter((_, index) => index !== selectedIndex);
                    setDropZone(newDropZone);
                    setSelectedDropZoneValue(null);

                    let finalGrid = gravity(newGrid);
                    finalGrid = mergeBlocks(finalGrid);
                    finalGrid = gravity(finalGrid);
                    finalGrid = mergeBlocks(finalGrid);

                    setGrid(finalGrid);
                }
            };
            
            // --- Special Blocks Logic ---
            const handleBuySpecialBlock = (type) => {
                const cost = SPECIAL_BLOCKS_COST[type];
                if (score >= cost) {
                    setScore(score - cost);
                    setSpecialBlocks(prev => ({ ...prev, [type]: prev[type] + 1 }));
                    setMessage(`Purchased a ${type} block!`);
                } else {
                    setMessage('Not enough score to buy this block.');
                }
            };

            const handleActivateSpecialBlock = (type) => {
                if (specialBlocks[type] > 0) {
                    setActiveSpecialBlock(type);
                    setSelectedDropZoneValue(null);
                    setMessage(`Activated ${type} block. Click on the grid to use it.`);
                } else {
                    setMessage('You do not own this block yet.');
                }
            };

            const handleGridClick = (r, c) => {
                // If a special block is active, use its ability
                if (activeSpecialBlock) {
                    let newGrid = [...grid];
                    let blockUsed = false;
                    let message = '';

                    switch (activeSpecialBlock) {
                        case 'swap':
                            if (!newGrid[r][c]) {
                                setMessage('You can only swap two existing blocks.');
                                return;
                            }
                            if (swapSelection.length === 0) {
                                setSwapSelection([r, c]);
                                setMessage('Select a second block to swap.');
                            } else {
                                const [r1, c1] = swapSelection;
                                if (!newGrid[r1][c1]) {
                                     setMessage('You can only swap two existing blocks.');
                                     return;
                                }
                                // Swap the blocks
                                const temp = newGrid[r][c];
                                newGrid[r][c] = newGrid[r1][c1];
                                newGrid[r1][c1] = temp;
                                
                                setSwapSelection([]);
                                blockUsed = true;
                                message = 'Blocks swapped!';
                            }
                            break;
                        case 'hammer':
                            if (newGrid[r][c]) {
                                newGrid[r][c] = null;
                                newGrid = gravity(newGrid);
                                blockUsed = true;
                                message = 'Block hammered!';
                            }
                            break;
                        case 'doubler':
                            if (newGrid[r][c]) {
                                newGrid[r][c].value *= 2;
                                blockUsed = true;
                                message = 'Block doubled!';
                            }
                            break;
                        case 'freeze':
                            if (newGrid[r][c]) {
                                newGrid[r][c].isFrozen = !newGrid[r][c]?.isFrozen;
                                blockUsed = true;
                                message = `Block is now ${newGrid[r][c].isFrozen ? 'frozen' : 'unfrozen'}!`;
                            }
                            break;
                        case 'bomb':
                            for(let row = 0; row < 5; row++) {
                                newGrid[row][c] = null;
                            }
                            newGrid = gravity(newGrid);
                            blockUsed = true;
                            message = 'Column bombed!';
                            break;
                    }

                    if (blockUsed) {
                        if (activeSpecialBlock !== 'freeze' || !newGrid[r][c]?.isFrozen) {
                            newGrid = mergeBlocks(newGrid);
                            newGrid = gravity(newGrid);
                        }
                        
                        setGrid(newGrid);
                        // Decrement block count and deactivate
                        if (activeSpecialBlock !== 'freeze' && activeSpecialBlock !== 'swap') {
                           setSpecialBlocks(prev => ({ ...prev, [activeSpecialBlock]: prev[activeSpecialBlock] - 1 }));
                        }
                        if (activeSpecialBlock !== 'swap' || swapSelection.length === 0) {
                            setActiveSpecialBlock(null);
                        }
                        setMessage(message);
                    }
                } 
                // Otherwise, perform a normal number drop
                else if (dropZone.length > 0 && selectedDropZoneValue) {
                    handleGridDrop(c);
                } else {
                    setMessage('Please select a number from the drop zone first, or activate a special block.');
                }
            };
            
            // --- Reset Game ---
            const handleReset = () => {
                setDropZone([]);
                setGrid(Array(5).fill(null).map(() => Array(5).fill(null)));
                setScore(0);
                setGameOver(false);
                setHighestValue(null);
                setSelectedDropZoneValue(null);
                setSpecialBlocks({
                    swap: 0,
                    hammer: 0,
                    doubler: 0,
                    freeze: 0,
                    bomb: 0,
                });
                setActiveSpecialBlock(null);
                setSwapSelection([]);
                setMessage('');
            };

            return (
                <div className="min-h-screen bg-gray-900 text-white p-4 flex flex-col items-center">
                    <div className="max-w-4xl w-full">
                        <h1 className="text-6xl font-extrabold text-center my-8 text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-purple-600">
                            DartMerge
                        </h1>

                        {/* Message box */}
                        {message && (
                            <div className="bg-blue-600 text-white p-3 rounded-lg text-center font-bold mb-4">
                                {message}
                            </div>
                        )}

                        {/* Top numbers section */}
                        <div className="bg-gray-800 p-4 rounded-xl shadow-lg mb-8">
                            <h2 className="text-2xl font-bold mb-4 text-center">Numbers to Drop</h2>
                            <div className="flex flex-wrap gap-2 justify-center">
                                {numbers.map((number, index) => (
                                    <button
                                        key={index}
                                        className={`${number.color} text-white font-bold py-3 px-6 rounded-lg shadow-md transition-all duration-200 ease-in-out transform hover:scale-110 active:scale-95 text-xl`}
                                        onClick={() => handleNumberClick(number.value)}
                                        disabled={dropZone.length >= 3}
                                    >
                                        {number.value}
                                    </button>
                                ))}
                            </div>
                        </div>

                        {/* Drop zone and undo button */}
                        <div className="bg-gray-800 p-4 rounded-xl shadow-lg mb-8 flex flex-col items-center">
                            <h2 className="text-2xl font-bold mb-4 text-center">Drop Zone ({dropZone.length}/3)</h2>
                            <div className="flex justify-center gap-4 w-full">
                                <div className="flex gap-2">
                                    {Array(3).fill(null).map((_, index) => (
                                        <div
                                            key={index}
                                            className={`w-24 h-16 rounded-lg shadow-inner flex items-center justify-center text-3xl font-bold transition-all duration-200
                                            ${dropZone[index]
                                                ? `${dropZone[index].color} text-white cursor-pointer`
                                                : 'bg-gray-700 text-gray-500'
                                            }
                                            ${selectedDropZoneValue === dropZone[index]?.value ? 'border-4 border-yellow-400' : ''}`}
                                            onClick={() => dropZone[index] && handleDropZoneClick(dropZone[index].value)}
                                        >
                                            {dropZone[index]?.value || ''}
                                        </div>
                                    ))}
                                </div>
                                <button
                                    className={`py-3 px-6 rounded-lg font-bold transition-all duration-200
                                    ${dropZone.length > 0 ? 'bg-red-500 hover:bg-red-600 active:scale-95' : 'bg-gray-600 cursor-not-allowed'}
                                    `}
                                    onClick={handleUndo}
                                    disabled={dropZone.length === 0}
                                >
                                    Undo
                                </button>
                            </div>
                        </div>

                        {/* Special Blocks Section */}
                        <div className="bg-gray-800 p-4 rounded-xl shadow-lg mb-8 flex flex-col items-center">
                            <h2 className="text-2xl font-bold mb-4 text-center">Special Blocks</h2>
                            <div className="flex flex-wrap gap-2 justify-center w-full">
                                {Object.keys(SPECIAL_BLOCKS_COST).map(type => (
                                    <div key={type} className="flex flex-col items-center p-2 rounded-lg bg-gray-700 shadow-md">
                                        <div className="text-sm text-gray-400 capitalize">{type}</div>
                                        <button
                                            className={`
                                                w-20 h-20 text-3xl rounded-lg shadow-md transition-all duration-200 ease-in-out
                                                ${activeSpecialBlock === type ? 'shadow-yellow-400 shadow-[0_0_15px] animate-pulse' : ''}
                                                ${score >= SPECIAL_BLOCKS_COST[type] ? 'bg-purple-600 hover:bg-purple-700 active:scale-95' : 'bg-gray-600 cursor-not-allowed'}
                                                ${specialBlocks[type] > 0 ? 'bg-green-600 hover:bg-green-700 active:scale-95' : ''}
                                            `}
                                            onClick={() => specialBlocks[type] > 0 ? handleActivateSpecialBlock(type) : handleBuySpecialBlock(type)}
                                            disabled={gameOver && activeSpecialBlock !== 'swap'}
                                        >
                                            <i className={`fas fa-${type === 'swap' ? 'exchange-alt' : type}`}></i>
                                        </button>
                                        <div className="text-xs text-gray-300 mt-1">
                                            Own: {specialBlocks[type]}
                                        </div>
                                        <div className="text-xs text-gray-500">
                                            Cost: {SPECIAL_BLOCKS_COST[type]}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>

                        {/* Game Grid and Score */}
                        <div className="bg-gray-800 p-6 rounded-xl shadow-lg mb-8 flex flex-col items-center">
                            <h2 className="text-2xl font-bold mb-4 text-center">Game Grid</h2>
                            <div className="grid grid-cols-5 gap-1 p-1 bg-gray-700 rounded-lg shadow-inner">
                                {grid.map((row, rowIndex) => (
                                    row.map((cell, colIndex) => (
                                        <div
                                            key={`${rowIndex}-${colIndex}`}
                                            className={`w-20 h-20 rounded-lg flex items-center justify-center text-2xl font-bold transition-all duration-300
                                            ${cell ? `${cell.color} text-white` : 'bg-gray-600 cursor-pointer'}
                                            ${cell?.value === highestValue && 'shadow-yellow-400 shadow-[0_0_15px]'}
                                            ${(activeSpecialBlock && !cell) && 'cursor-not-allowed'}
                                            ${cell?.isFrozen && 'border-4 border-blue-400'}
                                            `}
                                            onClick={() => handleGridClick(rowIndex, colIndex)}
                                        >
                                            {cell?.value || ''}
                                        </div>
                                    ))
                                ))}
                            </div>
                            <div className="mt-6 text-3xl font-bold text-center">
                                Score: <span className="text-green-400">{score}</span>
                            </div>
                            <button
                                onClick={handleReset}
                                className="mt-4 py-2 px-4 rounded-lg bg-red-500 text-white font-bold hover:bg-red-600 transition-all active:scale-95"
                            >
                                Reset Game
                            </button>
                            {gameOver && (
                                <div className="mt-4 text-4xl font-extrabold text-red-500 animate-pulse">
                                    GAME OVER!
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        };
        
        rootElement.render(<App />);

    </script>
</body>
</html>
