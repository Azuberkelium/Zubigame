<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DartMerge</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React, ReactDOM, and Babel CDNs for rendering the JSX -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="bg-gray-900 text-white font-sans">

    <!-- This is the root element where the React application will be rendered -->
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;
        const rootElement = ReactDOM.createRoot(document.getElementById('root'));

        // Main App component
        function App() {
            // Generates the initial numbers (2, 4, 8, ...) up to 32768
            const numbers = (() => {
                const nums = [];
                const colors = [
                    'bg-red-500', 'bg-blue-500', 'bg-green-500', 'bg-yellow-500', 'bg-purple-500',
                    'bg-pink-500', 'bg-indigo-500', 'bg-teal-500', 'bg-orange-500', 'bg-cyan-500',
                    'bg-fuchsia-500', 'bg-lime-500', 'bg-rose-500', 'bg-amber-500', 'bg-emerald-500'
                ];
                for (let i = 2, j = 0; i <= 32768; i *= 2, j++) {
                    nums.push({ value: i, color: colors[j % colors.length] });
                }
                return nums;
            })();

            const [dropZone, setDropZone] = useState([]);
            const [grid, setGrid] = useState(Array(5).fill(null).map(() => Array(5).fill(null)));
            const [score, setScore] = useState(0);
            const [gameOver, setGameOver] = useState(false);
            const [highestValue, setHighestValue] = useState(null);
            const [selectedDropZoneValue, setSelectedDropZoneValue] = useState(null);

            // Recalculate the score whenever the grid changes
            useEffect(() => {
                let newScore = 0;
                let newHighest = 0;
                let gridFull = true;
                for (const row of grid) {
                    for (const cell of row) {
                        if (cell) {
                            newScore += cell.value;
                            if (cell.value > newHighest) {
                                newHighest = cell.value;
                            }
                        } else {
                            gridFull = false;
                        }
                    }
                }
                setScore(newScore);
                setHighestValue(newHighest);
                setGameOver(gridFull);
            }, [grid]);

            // Handle clicking a number from the top section
            const handleNumberClick = (value) => {
                if (dropZone.length < 3) {
                    // Find the number in the main pool and add a copy to the drop zone
                    const numberToAdd = numbers.find(n => n.value === value);
                    if (numberToAdd) {
                        setDropZone([...dropZone, { ...numberToAdd }]);
                    }
                }
            };

            // Handle clicking the undo button
            const handleUndo = () => {
                if (dropZone.length > 0) {
                    const newDropZone = dropZone.slice(0, -1);
                    setDropZone(newDropZone);
                    // Deselect the drop zone number if it was the one being removed
                    if (selectedDropZoneValue === dropZone[dropZone.length - 1]?.value) {
                        setSelectedDropZoneValue(null);
                    }
                }
            };

            // Handle clicking a number in the drop zone
            const handleDropZoneClick = (value) => {
                setSelectedDropZoneValue(value);
            };

            // Recursive function to merge adjacent blocks
            const mergeBlocks = (currentGrid) => {
                let merged = false;
                let newGrid = JSON.parse(JSON.stringify(currentGrid));

                const checkAndMerge = (r, c) => {
                    if (newGrid[r][c]) {
                        const value = newGrid[r][c].value;
                        const neighbors = [
                            [r - 1, c], [r + 1, c], [r, c - 1], [r, c + 1]
                        ];

                        for (const [nr, nc] of neighbors) {
                            if (nr >= 0 && nr < 5 && nc >= 0 && nc < 5 && newGrid[nr][nc] && newGrid[nr][nc].value === value) {
                                // Merge the two blocks
                                newGrid[r][c] = { value: value * 2, color: newGrid[r][c].color };
                                newGrid[nr][nc] = null;
                                merged = true;
                                // Recursively check for new merges from the position of the new block
                                newGrid = gravity(newGrid);
                                newGrid = mergeBlocks(newGrid);
                                return;
                            }
                        }
                    }
                };

                for (let r = 0; r < 5; r++) {
                    for (let c = 0; c < 5; c++) {
                        if (newGrid[r][c]) {
                            checkAndMerge(r, c);
                            if(merged) break;
                        }
                    }
                    if(merged) break;
                }
                return newGrid;
            };

            // Apply gravity: numbers fall to the lowest available spot
            const gravity = (currentGrid) => {
                const newGrid = currentGrid.map(row => [...row]);
                for (let c = 0; c < 5; c++) {
                    let writeRow = 4;
                    for (let r = 4; r >= 0; r--) {
                        if (newGrid[r][c]) {
                            if (r !== writeRow) {
                                newGrid[writeRow][c] = newGrid[r][c];
                                newGrid[r][c] = null;
                            }
                            writeRow--;
                        }
                    }
                }
                return newGrid;
            };

            // Handle clicking a column in the grid to drop a number
            const handleGridDrop = (col) => {
                if (!selectedDropZoneValue) return;

                let newGrid = [...grid];
                let row = -1;
                // Find the lowest available spot in the column
                for (let r = 4; r >= 0; r--) {
                    if (!newGrid[r][col]) {
                        row = r;
                        break;
                    }
                }

                if (row !== -1) {
                    // Find the index of the selected number in the drop zone
                    const selectedIndex = dropZone.findIndex(n => n.value === selectedDropZoneValue);
                    if (selectedIndex === -1) return;

                    // Place the selected number
                    const selectedNumber = dropZone[selectedIndex];
                    newGrid[row][col] = selectedNumber;

                    // Remove from drop zone
                    const newDropZone = dropZone.filter((_, index) => index !== selectedIndex);
                    setDropZone(newDropZone);
                    setSelectedDropZoneValue(null);

                    // Apply gravity and then check for merges
                    let finalGrid = gravity(newGrid);
                    finalGrid = mergeBlocks(finalGrid);
                    finalGrid = gravity(finalGrid);
                    finalGrid = mergeBlocks(finalGrid); // Re-check after gravity

                    setGrid(finalGrid);
                }
            };

            return (
                <div className="min-h-screen bg-gray-900 text-white p-4 flex flex-col items-center">
                    <div className="max-w-4xl w-full">
                        <h1 className="text-6xl font-extrabold text-center my-8 text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-purple-600">
                            DartMerge
                        </h1>

                        {/* Top numbers section */}
                        <div className="bg-gray-800 p-4 rounded-xl shadow-lg mb-8">
                            <h2 className="text-2xl font-bold mb-4 text-center">Numbers to Drop</h2>
                            <div className="flex flex-wrap gap-2 justify-center">
                                {numbers.map((number, index) => (
                                    <button
                                        key={index}
                                        className={`${number.color} text-white font-bold py-3 px-6 rounded-lg shadow-md transition-all duration-200 ease-in-out transform hover:scale-110 active:scale-95 text-xl`}
                                        onClick={() => handleNumberClick(number.value)}
                                        disabled={dropZone.length >= 3}
                                    >
                                        {number.value}
                                    </button>
                                ))}
                            </div>
                        </div>

                        {/* Drop zone and undo button */}
                        <div className="bg-gray-800 p-4 rounded-xl shadow-lg mb-8 flex flex-col items-center">
                            <h2 className="text-2xl font-bold mb-4 text-center">Drop Zone ({dropZone.length}/3)</h2>
                            <div className="flex justify-center gap-4 w-full">
                                <div className="flex gap-2">
                                    {Array(3).fill(null).map((_, index) => (
                                        <div
                                            key={index}
                                            className={`w-24 h-16 rounded-lg shadow-inner flex items-center justify-center text-3xl font-bold transition-all duration-200
                                            ${dropZone[index]
                                                ? `${dropZone[index].color} text-white cursor-pointer`
                                                : 'bg-gray-700 text-gray-500'
                                            }
                                            ${selectedDropZoneValue === dropZone[index]?.value ? 'border-4 border-yellow-400' : ''}`}
                                            onClick={() => dropZone[index] && handleDropZoneClick(dropZone[index].value)}
                                        >
                                            {dropZone[index]?.value || ''}
                                        </div>
                                    ))}
                                </div>
                                <button
                                    className={`py-3 px-6 rounded-lg font-bold transition-all duration-200
                                    ${dropZone.length > 0 ? 'bg-red-500 hover:bg-red-600 active:scale-95' : 'bg-gray-600 cursor-not-allowed'}
                                    `}
                                    onClick={handleUndo}
                                    disabled={dropZone.length === 0}
                                >
                                    Undo
                                </button>
                            </div>
                        </div>

                        {/* Game Grid and Score */}
                        <div className="bg-gray-800 p-6 rounded-xl shadow-lg mb-8 flex flex-col items-center">
                            <h2 className="text-2xl font-bold mb-4 text-center">Game Grid</h2>
                            <div className="grid grid-cols-5 gap-1 p-1 bg-gray-700 rounded-lg shadow-inner">
                                {grid.map((row, rowIndex) => (
                                    row.map((cell, colIndex) => (
                                        <div
                                            key={`${rowIndex}-${colIndex}`}
                                            className={`w-20 h-20 rounded-lg flex items-center justify-center text-2xl font-bold transition-all duration-300
                                            ${cell ? `${cell.color} text-white` : 'bg-gray-600 cursor-pointer'}
                                            ${cell?.value === highestValue && 'shadow-yellow-400 shadow-[0_0_15px]'}
                                            `}
                                            onClick={() => dropZone.length > 0 && selectedDropZoneValue && handleGridDrop(colIndex)}
                                        >
                                            {cell?.value || ''}
                                        </div>
                                    ))
                                ))}
                            </div>
                            <div className="mt-6 text-3xl font-bold text-center">
                                Score: <span className="text-green-400">{score}</span>
                            </div>
                            {gameOver && (
                                <div className="mt-4 text-4xl font-extrabold text-red-500 animate-pulse">
                                    GAME OVER!
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        }

        rootElement.render(<App />);

    </script>
</body>
</html>
